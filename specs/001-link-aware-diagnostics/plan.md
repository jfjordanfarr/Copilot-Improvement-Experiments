# Implementation Plan: Link-Aware Diagnostics

**Branch**: `001-link-aware-diagnostics` | **Date**: 2025-10-16 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-link-aware-diagnostics/spec.md`

**Note**: This template is filled in by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Deliver a VS Code-based experience that keeps markdown documentation layers, implementation files, and dependent modules in sync by surfacing drift diagnostics and providing acknowledgement workflows. The solution pairs a lightweight VS Code extension client with a Node-based language server that builds a shared dependency/documentation graph stored in SQLite. Rather than relying on hand-authored metadata, the server treats links as a rebuildable index generated by a layered inference pipeline: heuristic/LLM analysis provides the baseline graph even when no language-server data exists, while optional symbol/reference feeds from existing providers (via `execute*Provider` calls and incremental sync) and external knowledge graphs improve accuracy. Manual overrides remain available when inference needs correction. Optional LLM reasoning via the `vscode.lm` API augments multi-hop impact analysis. Diagnostics remain disabled until the user explicitly selects an LLM provider through the extension’s onboarding flow, honoring Responsible Intelligence commitments. Hysteresis controls pause reciprocal diagnostics until acknowledgements land, rapid edit bursts are debounced through configurable batching, workspace settings expose noise suppression, LLM provider mode, and storage options, and a knowledge-graph bridge (e.g., GitLab Knowledge Graph) broadens cross-artifact monitoring beyond markdown↔code pairs while enforcing a shared schema contract.

## Technical Context

<!--
  ACTION REQUIRED: Replace the content in this section with the technical details
  for the project. The structure here is presented in advisory capacity to guide
  the iteration process.
-->

**Language/Version**: TypeScript 5.x targeting Node.js 20 for extension + LSP, SQL schema for SQLite 3  
**Primary Dependencies**: VS Code Extension API, `vscode-languageclient`/`vscode-languageserver`, `better-sqlite3`, Tree-sitter parsers where gaps remain, optional LLM access via `vscode.lm`  
**Storage**: Embedded SQLite property-graph tables persisted under workspace storage for diagnostics history  
**Testing**: `@vscode/test-electron` for extension integration, `vitest` for shared modules, contract smoke tests for custom LSP requests  
**Target Platform**: VS Code desktop (Windows/macOS/Linux) with optional headless language server for CI  
**Project Type**: Multi-package workspace (extension client, language server, shared graph utilities)  
**Performance Goals**: Surface 95% of relevant diagnostics within 5 seconds of file save; background graph updates complete within 10 seconds for 1k-node graphs  
**Constraints**: Minimize false positives via confidence scoring, operate offline with local storage, block diagnostics until an LLM provider or explicit opt-out is chosen, respect user-configured model/provider policies, uphold acknowledgement-driven hysteresis, and support configurable debounce windows for change batching  
**Scale/Scope**: Initial pilot teams (<20 contributors) with codebases up to ~1M LOC and documentation sets spanning the four-layer hierarchy

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- Constitution v1.0.0 principles (Documentation-Implementation Unity, Tooling Leverage & Reuse, Responsible Intelligence & Consent, Fast Feedback & Verification, Simplicity & Stewardship) are observed. ✅ No violations detected; onboarding requirement for LLM consent is captured in design and Complexity Tracking remains empty.

## Project Structure

### Documentation (this feature)

```
specs/[###-feature]/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)
<!--
  ACTION REQUIRED: Replace the placeholder tree below with the concrete layout
  for this feature. Delete unused options and expand the chosen structure with
  real paths (e.g., apps/admin, packages/something). The delivered plan must
  not include Option labels.
-->

```
packages/
├── extension/             # VS Code client (activation, UI, settings)
├── server/                # Language server (graph builder, diagnostics engine)
└── shared/                # Reusable graph/domain logic, models, telemetry

data/
└── migrations/            # SQLite schema migrations if required

tests/
├── integration/           # Extension + server end-to-end scenarios
└── unit/                  # Shared utilities, graph calculations
```

**Structure Decision**: Adopt a multi-package workspace to keep client, server, and shared logic isolated yet reusable. Tests live alongside packages with integration coverage ensuring extension↔server coordination.

## Complexity Tracking

## Phases & Key Deliverables

- **Phase 0 – Research**: Finalize heuristic/LLM inference strategy (including GraphRAG-style generation when no language server is present), confirm reliance on VS Code providers vs. Tree-sitter fallbacks as optimizations, document LLM consent/onboarding flow, and evaluate external knowledge graph providers (GitLab Knowledge Graph, LSIF-derived graphs) for cross-artifact monitoring along with the schema contract they must satisfy.
- **Phase 1 – Domain & Contracts**: Ship data model, SQLite schema, language server contracts (including `workspace/selectLLMProvider` handshake), and quickstart instructions emphasising first-run provider selection.
- **Phase 2 – Foundations**: Scaffold extension/server packages, implement configuration surfaces (LLM provider selection gating, storage path, noise suppression), and build graph persistence primitives that run the baseline heuristic/LLM inference, incorporate VS Code workspace index data when available, and enforce the external knowledge-graph schema contract alongside override manifests to populate the rebuildable link graph.
- **Phase 3 – User Story 1 (Writers)**: Detect doc edits, enqueue debounced change batches, publish diagnostics with hysteresis, and ensure diagnostics stay blocked until provider consent is captured.
- **Phase 4 – User Story 2 (Developers)**: Extend dependency graph to code modules, reuse official language server data for dependents, and enrich diagnostics with quick navigation.
- **Phase 5 – User Story 3 (Leads)**: Build acknowledgement workflows, consolidated views, and telemetry that tracks acknowledgement latency without breaking hysteresis or consent rules.
- **Phase 6 – Hardening & Ops**: Add delete/rename repair tooling, performance validation (latency + ricochet metrics), inference accuracy benchmarking using a canonical repo, onboarding polish, and documentation for governance/compliance.

*Fill ONLY if Constitution Check has violations that must be justified*

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |
| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |

