# Falsifiability Test Architecture

## Purpose
Capture the architectural shape of the upcoming falsifiability pass for the link-aware diagnostics project. This layer-3 doc translates product-level quality expectations into concrete test fixtures, data flows, and suite boundaries before implementation.

## Linked Vision & Requirements
- Layer-1 seed: ensure link-aware diagnostics only alerts on meaningful cross-file impacts while remaining trustworthy for Copilot and humans.
- Layer-2 obligations (to be authored):
  - F1. Surface broken documentation links as first-class drift signals.
  - F2. Avoid ripple diagnostics for unrelated local-scope symbol edits.
  - F3. Detect ripple impact generated by transform-style assets (templates, metaprogramming outputs).

## Test Suite Overview
| Suite | Fixture Workspace | Primary Files | Diagnostic Flow | Expected Outcome |
|-------|-------------------|---------------|-----------------|------------------|
| MD-Link Drift | `tests/integration/us3/markdown-links/` | `docs/index.md`, `docs/api.md`, `src/api.ts` | Markdown link edits + file renames update `artifactWatcher`, seeding `documents`/`references` relationships via `pathReferenceDetector`. Ripple analyzer should emit documentation drift diagnostics against the referencing doc and dependent code. | Diagnostics appear when path is broken; quick action retains target metadata. |
| Scope Collision Guard | `tests/integration/us4/scoped-identifiers/` | `src/service.ts`, `src/service.test.ts` | Rapid edits to identical variable names in different scopes produce change events but no graph edges. | No diagnostics for untouched files; hysteresis budget untouched. |
| Transform Pipeline | `tests/integration/us5/template-ripples/` | `templates/web.config.debug.xslt` (or YAML-based template), `build/applyTransform.ts`, `config/web.config` | Transform artifact linked to generated output via bootstrap knowledge feed. Editing template propagates ripple diagnostics through transform script to generated config. | Dependent config file receives `code-ripple` diagnostic with depth and path metadata. |

## Fixture Design Notes
- **MD-Link Drift**
  - Use real markdown links (`[Doc](./api.md)`) so `pathReferenceDetector` emits deterministic `documents` hints without manual graph seeding.
  - Introduce rename scenario by editing `api.md` to `api-reference.md` during test; ensure watcher captures file rename by writing new file then deleting old path (mirrors user action).
  - Provide knowledge bootstrap linking `api.md` to `src/api.ts` to exercise mixed doc â†’ code ripple.

- **Scope Collision Guard**
  - Deliberately craft nested functions using `const data =` at different scopes and in companion test file to mimic imports.
  - Ensure no markdown or import references cross files, so any emitted ripple indicates a false positive.
  - Add assertions that diagnostics array stays empty for sibling files even after multiple saves.

- **Transform Pipeline**
  - Prefer Node-friendly transform (e.g., Handlebars/YAML-to-JSON) to avoid heavy external tooling.
  - Bootstrap knowledge feed describing `template -> transform script -> output config` relationships using `implements` / `depends_on` kinds to drive ripple depth > 1.
  - Validate metadata (`depth`, `path`, `confidence`) within diagnostic data to guarantee chain reasoning.

## Automation Hooks
- Extend VS Code integration harness to accept workspace fixture name parameter so suites can share onboarding logic.
- Augment knowledge bootstrap loader to inject suite-specific feeds located inside each fixture.
- Ensure ready-to-commit task runs new suites sequentially to avoid VS Code instance contention.

## Open Questions
1. Should broken markdown link detection emit a specialized diagnostic code distinct from `doc-drift`? (Impacts quick-fix messaging.)
2. How to best simulate file renames within integration harness while respecting debounced change queue?
3. Can transform scenario reuse existing bootstrap ingestion flow without custom commands?

## Next Steps
1. Draft Layer-2 requirements doc referencing this architecture.
2. Implement fixtures, bootstrap feeds, and integration suites per table above.
3. Backfill unit tests where suites rely on new helper utilities (e.g., rename helpers, transform pipeline mocks).
